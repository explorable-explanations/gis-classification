{"version":3,"sources":["../../src/core/constants.ts","../../src/core/classification.ts","../../src/core/color-utils.ts","../../src/core/palettes.ts","../../src/core/format.ts","../../src/core/colorize.ts","../../src/core/histogram.ts"],"names":["statBreaks","color","d3sc","range","d3Format","scaleThreshold","d3Bin","extent","mean"],"mappings":"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","file":"index.cjs","sourcesContent":["import type {ClassificationMethod} from './types';\n\nexport const CLASSIFICATION_METHODS: Record<ClassificationMethod, string> = {\n  quantile: '等量分類 (Quantile)',\n  equal: '等間隔分類 (Equal Interval)',\n  jenks: '自然分類 (Jenks)',\n  msd: '標準偏差 (Mean-Std Dev)',\n  geometric: '幾何学的分類 (Geometric)',\n  headtail: 'ヘッドテール分類 (Head/Tail)',\n  pretty: 'きりのよい分類 (Pretty)',\n  arithmetic: '等差分類 (Arithmetic)',\n  nestedmeans: '入れ子平均 (Nested Means)',\n  q6: 'Q6分類 (Q6)',\n  custom: 'カスタム (Custom)',\n};\n\nexport const SEQUENTIAL_SCHEMES = [\n  'Blues', 'Greens', 'Greys', 'Oranges', 'Purples', 'Reds',\n  'BuGn', 'BuPu', 'GnBu', 'OrRd', 'PuBu', 'PuBuGn',\n  'PuRd', 'RdPu', 'YlGn', 'YlGnBu', 'YlOrBr', 'YlOrRd',\n];\n\nexport const DIVERGING_SCHEMES = [\n  'BrBG', 'PiYG', 'PRGn', 'PuOr', 'RdBu', 'RdGy',\n  'RdYlBu', 'RdYlGn', 'Spectral',\n];\n\nexport const QUALITATIVE_SCHEMES = [\n  'Accent', 'Dark2', 'Paired', 'Pastel1', 'Pastel2',\n  'Set1', 'Set2', 'Set3', 'Tableau10',\n];\n\nexport const DEFAULT_METHOD: ClassificationMethod = 'quantile';\nexport const DEFAULT_NB_CLASSES = 5;\nexport const DEFAULT_PALETTE = 'Blues';\nexport const DEFAULT_MISSING_COLOR = '#f5f5f5';\nexport const DEFAULT_MISSING_TEXT = 'No data';\n","import type {ClassificationOptions, ClassificationResult} from './types';\nimport type {ClassificationMethod} from './types';\nimport {breaks as statBreaks} from 'statsbreaks';\n\nexport function classify(\n  data: number[],\n  options: ClassificationOptions\n): ClassificationResult {\n  const cleanData = data\n    .filter((d): d is number => d !== undefined && d !== null && !isNaN(+d) && d !== ('' as any));\n\n  if (cleanData.length === 0) {\n    return {breaks: [], innerBreaks: [], nClasses: 0};\n  }\n\n  // 'custom' is not a statsbreaks method; breaks are managed externally\n  if (options.method === 'custom') {\n    return {breaks: [], innerBreaks: [], nClasses: 0};\n  }\n\n  // nestedmeans requires nb to be a power of 2\n  let nb = options.nb;\n  if (options.method === 'nestedmeans' && nb !== undefined) {\n    const log2 = Math.log2(nb);\n    nb = Math.pow(2, Math.round(log2));\n    if (nb < 2) nb = 2;\n  }\n\n  const allBreaks = statBreaks(cleanData, {\n    method: options.method,\n    nb,\n    precision: options.precision,\n    k: options.k,\n    middle: options.middle,\n    minmax: true,\n  });\n\n  const innerBreaks = allBreaks.slice(1, -1);\n\n  return {\n    breaks: allBreaks,\n    innerBreaks,\n    nClasses: allBreaks.length - 1,\n  };\n}\n\nexport const METHODS: ClassificationMethod[] = [\n  'quantile', 'q6', 'equal', 'jenks', 'msd',\n  'geometric', 'headtail', 'pretty', 'arithmetic', 'nestedmeans',\n  'custom',\n];\n","import {color} from 'd3-color';\nimport type {HexColor} from './types';\n\nexport function colorToHex(c: string): HexColor {\n  const parsed = color(c);\n  if (!parsed) return c;\n  return parsed.formatHex();\n}\n\nexport function hexToRgb(hex: string): [number, number, number] {\n  const parsed = color(hex);\n  if (!parsed) return [0, 0, 0];\n  const rgb = parsed.rgb();\n  return [rgb.r, rgb.g, rgb.b];\n}\n","import * as d3sc from 'd3-scale-chromatic';\nimport {range} from 'd3-array';\nimport {colorToHex} from './color-utils';\nimport {SEQUENTIAL_SCHEMES, DIVERGING_SCHEMES, QUALITATIVE_SCHEMES} from './constants';\nimport type {PaletteEntry, PaletteType, HexColor} from './types';\n\nfunction buildPaletteEntry(name: string, type: PaletteType): PaletteEntry {\n  const scheme = (d3sc as any)[`scheme${name}`];\n  const interpolator = (d3sc as any)[`interpolate${name}`];\n\n  let maxClasses: number;\n  if (type === 'qualitative' && Array.isArray(scheme)) {\n    maxClasses = scheme.length;\n  } else if (Array.isArray(scheme)) {\n    maxClasses = scheme.length - 1;\n  } else {\n    maxClasses = 12;\n  }\n\n  return {\n    name,\n    type,\n    maxClasses,\n    colors: (n: number): HexColor[] => {\n      const clamped = Math.max(1, Math.min(n, maxClasses));\n      if (type === 'qualitative' && Array.isArray(scheme)) {\n        return scheme.slice(0, clamped).map(colorToHex);\n      }\n      if (Array.isArray(scheme) && scheme[clamped]) {\n        return [...scheme[clamped]].map(colorToHex);\n      }\n      if (interpolator) {\n        if (clamped === 1) return [colorToHex(interpolator(0.5))];\n        return range(clamped).map(i => colorToHex(interpolator(i / (clamped - 1))));\n      }\n      return [];\n    },\n  };\n}\n\nexport const ALL_PALETTES: PaletteEntry[] = [\n  ...SEQUENTIAL_SCHEMES.map(n => buildPaletteEntry(n, 'sequential')),\n  ...DIVERGING_SCHEMES.map(n => buildPaletteEntry(n, 'diverging')),\n  ...QUALITATIVE_SCHEMES.map(n => buildPaletteEntry(n, 'qualitative')),\n];\n\nexport function getPaletteByName(name: string): PaletteEntry | undefined {\n  return ALL_PALETTES.find(p => p.name === name);\n}\n\nexport function getPalettesByType(type: PaletteType | 'all'): PaletteEntry[] {\n  if (type === 'all') return ALL_PALETTES;\n  return ALL_PALETTES.filter(p => p.type === type);\n}\n","import {format as d3Format} from 'd3-format';\n\nexport function formatNumber(n: number): string {\n  if (!Number.isFinite(n)) return String(n);\n  const abs = Math.abs(n);\n  if (abs === 0) return '0';\n  if (abs < 1) return d3Format('.4~f')(n);\n  if (abs < 1000) return d3Format('.4~r')(n);\n  if (abs < 10000) return d3Format(',.2~f')(n);\n  return d3Format('.4~s')(n);\n}\n","import {scaleThreshold, scaleOrdinal} from 'd3-scale';\nimport {classify} from './classification';\nimport {getPaletteByName} from './palettes';\nimport {formatNumber} from './format';\nimport {DEFAULT_METHOD, DEFAULT_NB_CLASSES, DEFAULT_PALETTE, DEFAULT_MISSING_COLOR, DEFAULT_MISSING_TEXT} from './constants';\nimport type {ClassificationMethod, ColorizeResult, BreakLegendEntry, HexColor} from './types';\n\nexport function colorizeChoropleth(\n  values: number[],\n  options: {\n    method?: ClassificationMethod;\n    nClasses?: number;\n    palette?: string;\n    colors?: HexColor[];\n    breaks?: number[];\n    precision?: number;\n    k?: number;\n    middle?: boolean;\n    reversed?: boolean;\n    missingColor?: HexColor;\n    missingText?: string;\n  } = {}\n): ColorizeResult {\n  const method = options.method ?? DEFAULT_METHOD;\n  const nClasses = options.nClasses ?? DEFAULT_NB_CLASSES;\n  const missingColor = options.missingColor ?? DEFAULT_MISSING_COLOR;\n  const missingText = options.missingText ?? DEFAULT_MISSING_TEXT;\n\n  let allBreaks: number[];\n  if (options.breaks) {\n    allBreaks = [...options.breaks].sort((a, b) => a - b);\n  } else {\n    const result = classify(values, {\n      method,\n      nb: nClasses,\n      precision: options.precision,\n      k: options.k,\n      middle: options.middle,\n    });\n    allBreaks = result.breaks;\n  }\n\n  let colors: HexColor[];\n  if (options.colors) {\n    colors = options.colors;\n  } else {\n    const paletteName = options.palette ?? DEFAULT_PALETTE;\n    const entry = getPaletteByName(paletteName);\n    colors = entry ? entry.colors(allBreaks.length - 1) : [];\n  }\n\n  if (options.reversed) {\n    colors = [...colors].reverse();\n  }\n\n  const innerBreaks = allBreaks.slice(1, -1);\n\n  const scale = scaleThreshold<number, string>()\n    .domain(innerBreaks)\n    .range(colors)\n    .unknown(missingColor);\n\n  const hasMissing = values.some(v => v == null || v === ('' as any) || isNaN(+v));\n  const missing: [string, HexColor] | null = hasMissing ? [missingText, missingColor] : null;\n\n  return {\n    getColor: (value) => {\n      if (value === '' || value == null || isNaN(+(value as number))) {\n        return missingColor;\n      }\n      return scale(+(value as number));\n    },\n    breaks: allBreaks,\n    colors,\n    missing,\n  };\n}\n\nexport function breaksToLegend(breaks: number[], colors: HexColor[]): BreakLegendEntry[] {\n  if (breaks.length < 2 || colors.length === 0) return [];\n\n  return colors.map((color, i) => {\n    const lower = i === 0 ? null : breaks[i];\n    const upper = i === colors.length - 1 ? null : breaks[i + 1];\n    let label: string;\n    if (lower === null) {\n      label = `< ${formatNumber(breaks[1])}`;\n    } else if (upper === null) {\n      label = `${formatNumber(breaks[i])} +`;\n    } else {\n      label = `${formatNumber(lower)} - ${formatNumber(upper)}`;\n    }\n    return {color, label, range: [lower, upper]};\n  });\n}\n","import {bin as d3Bin, extent, mean} from 'd3-array';\nimport type {Bin} from './types';\n\nexport function computeHistogram(values: number[], numBins = 30): Bin[] {\n  const clean = values.filter(d => d != null && !isNaN(d));\n  if (clean.length === 0) return [];\n\n  const bins = d3Bin().thresholds(numBins)(clean);\n\n  return bins.map(b => ({\n    x0: b.x0 ?? 0,\n    x1: b.x1 ?? 0,\n    count: b.length,\n  }));\n}\n\nexport function getHistogramDomain(values: number[]): {min: number; max: number; mean: number} {\n  const clean = values.filter(d => d != null && !isNaN(d));\n  const [min, max] = extent(clean) as [number, number];\n  const avg = mean(clean) ?? 0;\n  return {min: min ?? 0, max: max ?? 0, mean: avg};\n}\n"]}